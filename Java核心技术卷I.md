# 第1章 Java程序设计概述
## 1.1 Java程序设计平台

Java是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码，以及一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。
## 1.2 Java“白皮书”的关键术语
### 1.2.1 简单性
### 1.2.2 面向对象
### 1.2.3 分布式

Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。
### 1.2.4 健壮性
### 1.2.5 安全性

Java要适用于网络/分布式环境。为了实现这个目标，安全性颇受重视。使用Java可以构建防病毒、防篡改的系统。

从一开始，Java就设计成能够防范各种攻击，其中包括：

（1）运行时堆栈溢出，这是蠕虫和病毒常用的攻击手段。

（2）破坏自己的进程空间之外的内存。

（3）未经授权读写文件。

原先，Java对下载代码的态度是“尽管来吧！”。不可信代码在一个沙箱环境中执行，在这里它不会影响主系统。用户可以确信不会发生不好的事情，因为Java代码不论来自哪里，都不能脱离沙箱。

不过，Java的安全模型很复杂。Java开发包（JDK）的第一版发布之后不久，普林斯顿大学的一些安全专家就发现一些小bug会允许不可信的代码攻击主系统。

最初，安全bug可以快速修复。遗憾的是，经过一段时间之后，黑客已经很擅长找出安全体系结构实现中的小漏洞。Sun以及之后的Oracle为不断修复bug经历了一段很是艰难的日子。

遭遇多次高调攻击之后，浏览器开发商和Oracle开始越来越谨慎。Java浏览器插件不再信任远程代码，除非代码有数字签名而且用户同意执行这个代码。

现在看来，尽管Java安全模型没有原先预想的那么成功，但Java在那个时代确实相当超前。微软提供了一种与之竞争的代码交付机制，其安全性完全依赖于数字签名。显然这是不够的，因为微软自身产品的任何用户都可以证实，一些知名开发商的程序确实会崩溃并对系统产生危害。
### 1.2.6 体系结构中立

编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，这些编译后的代码可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心设计的字节码不仅可以很容易地在任何机器上解释执行，而且还可以动态地转换成本地机器代码。
### 1.2.7 可移植性

除了与用户界面有关的部分外，所有其他Java库能很好地支持平台独立性。你可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，而不用操心底层操作系统。不仅程序是可移植的，Java API往往也比原生API质量更高。
### 1.2.8 解释型

Java解释器可以在任何移植了解释器的机器上直接执行Java字节码。由于连接是一个增量式且轻量级的过程，所以，开发过程也变得更加快捷，更加具有探索性。
### 1.2.9 高性能

即时编译器可以监控哪些代码频繁执行，并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集合，如果一个特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销这种优化。
### 1.2.10 多线程
### 1.2.11 动态性

从很多方面来看，Java与C或C++相比更加具有动态性。它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时类型信息十分简单。
## 1.3 Java applet与Internet

这里的想法很简单：用户从Internet下载Java字节码，并在自己的机器上运行。在网页中运行的Java程序称为applet。要使用applet，只需要一个启用Java的Web浏览器，它会为你执行字节码。不需要安装任何软件。任何时候只要访问包含applet的网页，都会得到程序的最新版本。最重要的是，要感谢虚拟机的安全性，它让我们不必担心来自恶意代码的攻击。

在网页中插入一个applet就如同在网页中嵌入一幅图片。applet会成为页面的一部分。文本环绕在applet所占据的空间周围。关键的一点是，这个图片是活动的。它可以对用户命令做出响应，改变外观，在运行它的计算机与提供它的计算机之间交换数据。
## 1.4 Java发展简史
## 1.5 关于Java的常见误解
# 第2章 Java程序设计环境
## 2.1 安装Java开发工具包
### 2.1.1 下载JDK
### 2.1.2 设置JDK
### 2.1.3 安装库源文件和文档
## 2.2 使用命令行工具

javac程序是一个Java编译器，它将文件Welcome.java编译成Welcome.class。java程序启动Java虚拟机，虚拟机执行编译器编译到类文件中的字节码。

编译器需要一个文件名（Welcome.java），而运行程序时，只需要指定类名（Welcome），不要带扩展名.java或.class。
## 2.3 使用集成开发环境
## 2.4 JShell

Java 9引入了另一种使用Java的方法。JShell程序提供了一个”读取-计算-打印循环”。键入一个Java表达式；JShell会评估你的输入，打印结果，等待你的下一个输入。
# 第3章 Java的基本程序设计结构
## 3.1 一个简单的Java应用程序

源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。

运行已编译的程序时，Java虚拟机总是从指定类中的main方法的代码开始执行，因此为了代码能够执行，在类的源文件中必须包含一个main方法。
## 3.2 注释

在Java中，有3种标记注释的方式。最常用的方式是使用//，其注释内容从//开始到本行结尾。

当需要更长的注释时，既可以在每行的注释前面标记//，也可以使用/\*和\*/注释界定符将一段比较长的注释括起来。（在Java中，/\* \*/注释不能嵌套。也就是说，不能简单地把代码用/\*和\*/括起来作为注释，因为这段代码本身可能也包含一个\*/界定符。

最后，第3种注释可以用来自动地生成文档。这种注释以/\*\*开始，以\*/结束。
## 3.3 数据类型
### 3.3.1 整型

| 类型 | 存储需求 | 取值范围 |
| :-: | :-: | :-: |
| int | 4字节 | -2147483648\~2147483647 |
| short | 2字节 | -32768\~32767 |
| long | 8字节 | -9223372036854775808\~9223372036854775807 |
| byte | 1字节 | -128\~127 |

长整型数值有一个后缀L或l（如4000000000L）。十六进制数值有一个前缀0x或0X（如0xCAFE）。八进制有一个前缀0，例如，010对应十进制中的8。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。

从Java 7开始，加上前缀0b或0B就可以写二进制数。例如，0b1001就是9。另外，同样是从Java 7开始，还可以为数字字面量加下划线，如用1_000_000（或0b1111_0010_0100_0000）表示100万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。
### 3.3.2 浮点类型

| 类型 | 存储需求 | 取值范围 |
| :-: | :-: | :-: |
| float | 4字节 | 大约±3.40282347E+38F（有效位数为6\~7位）|
| double | 8字节 | 大约±1.79769313486231570E+308（有效位数为15位）|

double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值）。在很多情况下，float类型的精度（6\~7位有效数字）并不能满足需求。实际上，只有很少的情况适合使用float类型，例如，需要单精度数的库，或者需要存储大量数据时。

float类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）总是默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）。

可以使用十六进制表示浮点数值。例如，0.125可以表示成0x1.0p-3。在十六进制表示法中，使用p表示指数，而不是e。（e是一个十六进制数位。）注意，尾数采用十六进制，指数采用十进制。指数的基数是2，而不是10。

所有的浮点数值计算都遵循IEEE 754规范。一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。

不能如下检测一个特定值是否等于Double.NaN：

```java
if (x == Double.NaN)  // is never true
```

所有“非数值”的值都认为是不相同的。不过，可以使用Double.isNaN方法来判断：

```java
if (Double.isNaN(x))  // check whether x is "not a number"
```

浮点数值不适用于无法接受舍入误差的金融计算。例如，命令System.out.println(2.0-1.1)将打印出0.8999999999999999，而不是人们期望的0.9。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数1/10。这就好像十进制无法精确地表示分数1/3一样。如果在数值计算中不允许有任何舍入误差，就应该使用BigDecimal类。
### 3.3.3 char类型

char类型的字面量值要用单引号括起来。例如：'A'是编码值为65的字符常量。它与“A”不同，“A”是包含一个字符A的字符串。char类型的值可以表示为十六进制值，其范围从\\u0000到\\uFFFF。
### 3.3.4 Unicode和char类型

要想弄清char类型，就必须了解Unicode编码机制。Unicode打破了传统字符编码机制的限制。在Unicode出现之前，已经有许多种不同的标准：美国的ASCII、西欧语言中的ISO 8859-1、俄罗斯的KOI-8、中国的GB 18030和BIG-5等。这样就产生了下面两个问题：一个是`对于任意给定的代码值，在不同的编码方案下有可能对应不同的字母`；二是`采用大字符集的语言其编码长度有可能不同`。例如，有些常用的字符采用单字节编码，而另一些字符则需要两个或多个字节。

设计Unicode编码的目的就是要解决这些问题。在20世纪80年代开始启动统一工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来扩展，当时所有人都这么想。在1991年发布了Unicode 1.0，当时仅占用65536个代码值中不到一半的部分。在设计Java时决定采用16位的Unicode字符集，这比使用8位字符集的其他程序设计语言有了很大的改进。

十分遗憾的是，经过一段时间后，不可避免的事情发生了。Unicode字符超过了65536个，其主要原因是增加了大量的汉语、日语和韩语中的表意文字。现在，16位的char类型已经不能满足描述所有Unicode字符的需要了。

下面利用一些专用术语来解释Java语言从Java 5开始如何解决这个问题。`码点`是指与一个编码表中的某个字符对应的代码值。在Unicode标准中，码点采用十六进制书写，并加上前缀U+，例如U+0041就是拉丁字母A的码点。Unicode的码点可以分成17个`代码平面`。第一个代码平面称为`基本多语言平面`，包括码点从U+0000到U+FFFF的`“经典”Unicode代码`；其余的16个平面的码点为从U+10000到U+10FFFF，包括辅助字符。

UTF-16编码采用不同长度的编码表示所有Unicode码点。在基本多语言平面中，每个字符用16位表示，通常称为`代码单元`；而辅助字符编码为一对连续的代码单元。采用这种编码对表示的各个值落入基本多语言平面中未用的2048个值范围内，通常称为替代区域（U+D800\~U+DBFF用于第一个代码单元，U+DC00\~U+DFFF用于第二个代码单元）。这样的设计十分巧妙，我们可以从中迅速知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。

在Java中，char类型描述了UTF-16编码中的一个代码单元。

我们强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。
### 3.3.5 boolean类型
## 3.4 变量与常量
### 3.4.1 声明变量
### 3.4.2 变量初始化

从Java 10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明类型。只需要使用关键字var而无须指定类型。

```java
var vacationDays = 12;  // vacationDays is an int
var greeting = "Hello"; // greeting is a String
```
### 3.4.3 常量

在Java中，利用关键字final指示常量。关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。吸管刷，常量名使用全大写。

在Java中，经常希望某个常量可以在一个类的多个方法中使用，通常将这些常量称为类常量。可以使用关键字static final设置一个类常量。
### 3.4.4 枚举类型
## 3.5 运算符
### 3.5.1 算术运算符

整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大和NaN结果。

可移植性是Java语言的设计目标之一。无论在哪个虚拟机上运行，同一运算应该得到同样的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double类型使用64位存储一个数值，而有些处理器则使用80位浮点处理器。这些寄存器增加了中间过程的计算精度。例如，以下运算：

```java
double w = x * y / z;
```

很多Intel处理器计算x \* y，并且将结果存储在80位的寄存器中，再除以z并将结果截断为64位。这样可以得到一个更加精确的计算结果，并且还能够避免产生指数溢出。但是，这个结果可能与始终使用64位计算的结果不一样。因此，Java虚拟机的最初规范规定所有的中间结果都必须进行截断。这种做法遭到了数字社区的反对。截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算速度上实际上要比精确计算慢。为此，Java程序设计语言承认了最优性能与理想的可再生性之间存在的冲突，并给予了改进。在默认情况下，现在虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用strictfp关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。

例如，可以把main方法标记为

```java
public static strictfp void main(String[] args)
```

那么，main方法中的所有指令都将使用严格的浮点计算。如果将一个类标记为strictfp，这个类中的所有方法都要使用严格的浮点计算。
### 3.5.2 数学函数与常量

Math类提供了一些方法使整数有更好的运算安全性。如果一个计算溢出，数学运算符只是悄悄地返回错误的结果而不做任何提醒。例如，10亿乘以3的计算结果将是-1294967296，因为最大的int值也只是刚刚超过20亿。不过，如果调用Math.multiplyExact(1000000000, 3)，就会生成一个异常。你可以捕获这个异常或者让程序终止，而不是允许它给出一个错误的结果然后悄无声息地继续运行。另外还有一些方法（addExact、substractExact、incrementExact、decrementExact和negateExact）也可以正确地处理int和long参数。
### 3.5.3 数值类型之间的转换

当用一个二元运算符连接两个值时，先要将两个操作数转换为同一种类型，然后再进行计算。

（1）如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。

（2）否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。

（3）否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。

（4）否则，两个操作数都将被转换为int类型。
### 3.5.4 强制类型转换
### 3.5.5 结合赋值和运算符

如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换。例如，如果x是一个int，则以下语句

```java
x += 3.5;
```

是合法的，将把x设置为(int)(x + 3.5)。
### 3.5.6 自增与自减运算符
### 3.5.7 关系和boolean运算符
### 3.5.8 位运算符

应用在布尔值上时，\&和\|运算符也会得到一个布尔值。这些运算符与\&\&和\|\|运算符很类似，不过\&和\|运算符不采用“短路”方式来求值，也就是说，得到计算结果之前两个操作数都需要计算。

移位运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）。例如，1<<35的值等同于1<<3。
### 3.5.9 括号与运算符级别
## 3.6 字符串
### 3.6.1 子串
### 3.6.2 拼接

如果需要把多个字符串放在一起，用一个界定符分隔，可以使用静态join方法：

```java
String all = String.join(" / ", "S", "M", "L", "XL");  // "S / M / L / XL"
```

在Java 11中，还提供了一个repeat方法：

```java
String repeated = "Java".repeat(3); // "JavaJavaJava"
```
### 3.6.3 不可变字符串

不可变字符串的优点：编译器可以让字符串`共享`。

为了弄清具体的工作方式，可以想象将各种字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。

Java的设计者认为共享带来的高效率远远胜过于提取子串、拼接字符串所带来的低效率。
### 3.6.4 检测字符串是否相等

一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否存放在同一个位置上。当然，如果字符串在同一个位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串副本放置在不同的位置上。

如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。但实际上`只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享`。
### 3.6.5 空串与null
### 3.6.6 码点与代码单元

Java字符串由char值序列组成。char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元。最常用的Unicode字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。

length方法将返回采用UTF-16编码表示给定字符串所需的代码单元数量。例如：

```java
String greeting = "Hello";
int n = greeting.length();  // 5
```

要想得到实际的长度，即码点数量，可以调用：

```java
int cpCount = greeting.codePointCount(0, greeting.length());
```

调用s.charAt(n)将返回位置n的代码单元，n介于0\~s.length() - 1之间。例如：

```java
char first = greeting.charAt(0);  // 'H'
char last = greeting.charAt(4); // 'o'
```

要想得到第i个码点，应该使用下列语句：

```java
int index = greeting.offsetByCodePoints(0, i);
int cp = greeting.codePointAt(index);
```

为什么会对代码单元如此大惊小怪？请考虑以下语句：

```
𝕆 is the set of octonions.
```

使用UTF-16编码表示字符𝕆（U+1D546）需要两个代码单元。调用

```java
char ch = sentence.charAt(1);
```

返回的不是一个空格，而是𝕆的第二个代码单元。为了避免这个问题，不要使用char类型。这太底层了。

如果想要遍历一个字符串，并且一次查看每一个码点，可以使用下列语句：

```java
int cp = sentence.codePointAt(i);
if (Character.isSupplementartCodePoint(cp)) {
    i += 2;
} else {
    i++;
}
```

可以使用下列语句实现反向遍历：

```java
i--;
if (Character.isSurrogate(sentence.charAt(i))) {
    i--;
}
int cp = sentence.codePointAt(i);
```

显然，这很麻烦。更容易的办法是使用codePoints方法，它会生成一个int值的“流”，每个int值对应一个码点。可以将它转换为一个数组，再完成遍历。

```java
int[] codePoints = str.codePoints().toArray();
```

反之，要把一个码点数组转换为一个字符串，可以使用构造器。

```java
String str = new String(codePoints, 0, codePoints.length);
```

虚拟机不一定把字符串实现为代码单元序列。在Java 9中，只包含单字节代码单元的字符串使用byte数组实现，所有其他字符串使用char数组。
### 3.6.7 String API
### 3.6.8 阅读联机API文档
### 3.6.9 构建字符串

有些时候，需要由较短的字符串构建字符串，例如，按键或来自文件中的单词。如果采用字符串拼接的方式来达到这个目的，效率会比较低。每次拼接字符串时，都会构建一个新的String对象，既耗时，又浪费空间。使用StringBuilder类就可以避免这个问题的发生。
## 3.7 输入与输出
### 3.7.1 读取输入

```java
public class InputTest {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // get first input
        System.out.print("What is your name? ");
        String name = in.nextLine();

        // get second input
        System.out.print("How old are you? ");
        int age = in.nextInt();

        // display output on console
        System.out.println("Hello, " + name + ". Next year, you'll be " + (age + 1));
    }
}
```

因为输入是可见的，所以Scanner类不适用于从控制台读取密码。Java 6特别引入了Console类来实现这个目的。要想读取一个密码，可以使用下列代码：

```java
Console cons = System.console();  // 如果可以进行交互，就返回一个Console对象通过控制台窗口与用户交互，否则返回null。对于任何一个在控制台窗口启动的程序，都可使用Console对象。否则，是否可用取决于所使用的系统。
String username = cons.readLine("User name: ");
char[] passwd = cons.readPassword("Password: ");
```

为安全起见，返回的密码存放在一个字符数组中，而不是字符串中。在对密码处理完成之后，应该马上用一个填充值覆盖数组元素。

采用Console对象处理输入不如采用Scanner方便。必须每次读取一行输入，而没有能够读取单个单词或数值的方法。
### 3.7.2 格式化输出
### 3.7.3 文件输入与输出

要想读取一个文件，需要构造一个Scanner对象，如下所示：

```java
Scanner in = new Scanner(Path.of("myfile.txt"), StandardCharsets.UTF_8);
```

如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠转义。

在这里指定了UTF-8字符编码，这对于互联网上的文件很常见（不过并不是普遍适用）。读取一个文本文件时，要知道它的字符编码。如果省略字符编码，则会使用运行这个Java程序的机器的“默认编码”。这不是一个好主意，如果在不同的机器上运行这个程序，可能会有不同的表现。

要想写入文件，就需要构造一个PrintWriter对象。在构造器中，需要提供文件名和字符编码：

```java
PrintWriter out = new PrintWriter("myfile.txt", StandardCharsets.UTF_8);
```

如果文件不存在，创建该文件。可以像输出到System.out一样使用print、println以及printf命令。

如果用一个不存在的文件构造一个Scanner，或者用一个无法创建的文件名构造一个PrintWriter，就会产生异常。
## 3.8 控制流程
### 3.8.1 块作用域
### 3.8.2 条件语句
### 3.8.3 循环
### 3.8.4 确定循环
### 3.8.5 多重选择：switch语句

case标签可以是：

（1）类型为char、byte、short或int的常量表达式。

（2）枚举常量。

（3）从Java 7开始，case标签还可以是字符串字面量。
### 3.8.6 中断控制流程的语句
## 3.9 大数

如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中两个很有用的类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger类实现任意精度的整数运算，BigDecimal实现任意精度的浮点数运算。
## 3.10 数组
### 3.10.1 声明数组

在Java中，允许由长度为0的数组。
### 3.10.2 访问数组元素
### 3.10.3 for each循环

有一个简单的方式可以打印数组中的所有值，即利用Arrays类的toString方法。调用Arrays.toString(a)，返回一个包含数组元素的字符串，这些元素包围在中括号内，并用逗号分隔，例如，“\[2,3,5,7,11,13\]”。
### 3.10.4 数组拷贝
### 3.10.5 命令行参数
### 3.10.6 数组排序
### 3.10.7 多维数组

要想快速打印一个二维数组的数据元素列表，可以调用：

```java
System.out.println(Arrays.deepToString(a));
```
### 3.10.8 不规则数组
# 第4章 对象与类
## 4.1 面向对象程序设计概述
### 4.1.1 类
### 4.1.2 对象
### 4.1.3 识别类
### 4.1.4 类之间的关系

如果一个类的方法使用或操纵另一个类的对象，我们就说一个类`依赖`于另一个类。

`聚合`即“has-a”关系。例如，一个Order对象包含一些Item对象。

`继承`即“is-a”关系，表示一个更特殊的类与一个更一般的类之间的关系。
## 4.2 使用预定义类
### 4.2.1 对象与对象变量

对象变量并没有实际包含一个对象，它只是引用一个对象。

在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。new操作符的返回值也是一个引用。
### 4.2.2 Java类库中的LocalDate类

Java类库设计者将保存时间与给时间点命名分开：Date类用来表示时间点；LocalDate用日历表示法表示日期。

不要使用构造器来构造LocalDate类的对象。实际上，应当使用静态工厂方法，它会代表你调用构造器。下面的表达式：

```java
LocalDate.now();
```

会构造一个新对象，表示构造这个对象时的日期。

可以提供年、月和日来构造对应一个特定日期的对象：

```java
LocalDate.of(1999, 12, 31);
```

一旦有了一个LocalDate对象，可以用方法getYear、getMonthValue和getDayOfMonth得到年、月和日。
### 4.2.3 更改器方法与访问器方法
## 4.3 用户自定义类
### 4.3.1 Employee类
### 4.3.2 多个源文件的使用
### 4.3.3 剖析Employee类
### 4.3.4 从构造器开始

（1）构造器与类同名。

（2）每个类可以有一个以上的构造器。

（3）构造器可以有0个、1个或多个参数。

（4）构造器没有返回值。

（5）构造器总是伴随着new操作符一起调用。
### 4.3.5 用var声明局部变量

在Java 10中，如果可以从变量的初始值推导出它们的类型，那么可以用var关键字声明`局部变量`，而无须指定类型。

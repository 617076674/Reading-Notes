# 第1章 Java程序设计概述
## 1.1 Java程序设计平台

Java是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码，以及一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。
## 1.2 Java“白皮书”的关键术语
### 1.2.1 简单性
### 1.2.2 面向对象
### 1.2.3 分布式

Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。
### 1.2.4 健壮性
### 1.2.5 安全性

Java要适用于网络/分布式环境。为了实现这个目标，安全性颇受重视。使用Java可以构建防病毒、防篡改的系统。

从一开始，Java就设计成能够防范各种攻击，其中包括：

（1）运行时堆栈溢出，这是蠕虫和病毒常用的攻击手段。

（2）破坏自己的进程空间之外的内存。

（3）未经授权读写文件。

原先，Java对下载代码的态度是“尽管来吧！”。不可信代码在一个沙箱环境中执行，在这里它不会影响主系统。用户可以确信不会发生不好的事情，因为Java代码不论来自哪里，都不能脱离沙箱。

不过，Java的安全模型很复杂。Java开发包（JDK）的第一版发布之后不久，普林斯顿大学的一些安全专家就发现一些小bug会允许不可信的代码攻击主系统。

最初，安全bug可以快速修复。遗憾的是，经过一段时间之后，黑客已经很擅长找出安全体系结构实现中的小漏洞。Sun以及之后的Oracle为不断修复bug经历了一段很是艰难的日子。

遭遇多次高调攻击之后，浏览器开发商和Oracle开始越来越谨慎。Java浏览器插件不再信任远程代码，除非代码有数字签名而且用户同意执行这个代码。

现在看来，尽管Java安全模型没有原先预想的那么成功，但Java在那个时代确实相当超前。微软提供了一种与之竞争的代码交付机制，其安全性完全依赖于数字签名。显然这是不够的，因为微软自身产品的任何用户都可以证实，一些知名开发商的程序确实会崩溃并对系统产生危害。
### 1.2.6 体系结构中立

编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，这些编译后的代码可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心设计的字节码不仅可以很容易地在任何机器上解释执行，而且还可以动态地转换成本地机器代码。
### 1.2.7 可移植性

除了与用户界面有关的部分外，所有其他Java库能很好地支持平台独立性。你可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，而不用操心底层操作系统。不仅程序是可移植的，Java API往往也比原生API质量更高。
### 1.2.8 解释型

Java解释器可以在任何移植了解释器的机器上直接执行Java字节码。由于连接是一个增量式且轻量级的过程，所以，开发过程也变得更加快捷，更加具有探索性。
### 1.2.9 高性能

即时编译器可以监控哪些代码频繁执行，并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集合，如果一个特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销这种优化。
### 1.2.10 多线程
### 1.2.11 动态性

从很多方面来看，Java与C或C++相比更加具有动态性。它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时类型信息十分简单。
## 1.3 Java applet与Internet

这里的想法很简单：用户从Internet下载Java字节码，并在自己的机器上运行。在网页中运行的Java程序称为applet。要使用applet，只需要一个启用Java的Web浏览器，它会为你执行字节码。不需要安装任何软件。任何时候只要访问包含applet的网页，都会得到程序的最新版本。最重要的是，要感谢虚拟机的安全性，它让我们不必担心来自恶意代码的攻击。

在网页中插入一个applet就如同在网页中嵌入一幅图片。applet会成为页面的一部分。文本环绕在applet所占据的空间周围。关键的一点是，这个图片是活动的。它可以对用户命令做出响应，改变外观，在运行它的计算机与提供它的计算机之间交换数据。
## 1.4 Java发展简史
## 1.5 关于Java的常见误解
# 第2章 Java程序设计环境
## 2.1 安装Java开发工具包
### 2.1.1 下载JDK
### 2.1.2 设置JDK
### 2.1.3 安装库源文件和文档
## 2.2 使用命令行工具

javac程序是一个Java编译器，它将文件Welcome.java编译成Welcome.class。java程序启动Java虚拟机，虚拟机执行编译器编译到类文件中的字节码。

编译器需要一个文件名（Welcome.java），而运行程序时，只需要指定类名（Welcome），不要带扩展名.java或.class。
## 2.3 使用集成开发环境
## 2.4 JShell

Java 9引入了另一种使用Java的方法。JShell程序提供了一个”读取-计算-打印循环”。键入一个Java表达式；JShell会评估你的输入，打印结果，等待你的下一个输入。
# 第3章 Java的基本程序设计结构
## 3.1 一个简单的Java应用程序

源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。

运行已编译的程序时，Java虚拟机总是从指定类中的main方法的代码开始执行，因此为了代码能够执行，在类的源文件中必须包含一个main方法。
## 3.2 注释

在Java中，有3种标记注释的方式。最常用的方式是使用//，其注释内容从//开始到本行结尾。

当需要更长的注释时，既可以在每行的注释前面标记//，也可以使用/\*和\*/注释界定符将一段比较长的注释括起来。（在Java中，/\* \*/注释不能嵌套。也就是说，不能简单地把代码用/\*和\*/括起来作为注释，因为这段代码本身可能也包含一个\*/界定符。

最后，第3种注释可以用来自动地生成文档。这种注释以/\*\*开始，以\*/结束。
## 3.3 数据类型
### 3.3.1 整型

| 类型 | 存储需求 | 取值范围 |
| :-: | :-: | :-: |
| int | 4字节 | -2147483648\~2147483647 |
| short | 2字节 | -32768\~32767 |
| long | 8字节 | -9223372036854775808\~9223372036854775807 |
| byte | 1字节 | -128\~127 |

长整型数值有一个后缀L或l（如4000000000L）。十六进制数值有一个前缀0x或0X（如0xCAFE）。八进制有一个前缀0，例如，010对应十进制中的8。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。

从Java 7开始，加上前缀0b或0B就可以写二进制数。例如，0b1001就是9。另外，同样是从Java 7开始，还可以为数字字面量加下划线，如用1_000_000（或0b1111_0010_0100_0000）表示100万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。
### 3.3.2 浮点类型

| 类型 | 存储需求 | 取值范围 |
| :-: | :-: | :-: |
| float | 4字节 | 大约±3.40282347E+38F（有效位数为6\~7位）|
| double | 8字节 | 大约±1.79769313486231570E+308（有效位数为15位）|

double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值）。在很多情况下，float类型的精度（6\~7位有效数字）并不能满足需求。实际上，只有很少的情况适合使用float类型，例如，需要单精度数的库，或者需要存储大量数据时。

float类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）总是默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）。

可以使用十六进制表示浮点数值。例如，0.125可以表示成0x1.0p-3。在十六进制表示法中，使用p表示指数，而不是e。（e是一个十六进制数位。）注意，尾数采用十六进制，指数采用十进制。指数的基数是2，而不是10。

所有的浮点数值计算都遵循IEEE 754规范。一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。

不能如下检测一个特定值是否等于Double.NaN：

```java
if (x == Double.NaN)  // is never true
```

所有“非数值”的值都认为是不相同的。不过，可以使用Double.isNaN方法来判断：

```java
if (Double.isNaN(x))  // check whether x is "not a number"
```

浮点数值不适用于无法接受舍入误差的金融计算。例如，命令System.out.println(2.0-1.1)将打印出0.8999999999999999，而不是人们期望的0.9。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数1/10。这就好像十进制无法精确地表示分数1/3一样。如果在数值计算中不允许有任何舍入误差，就应该使用BigDecimal类。
### 3.3.3 char类型

char类型的字面量值要用单引号括起来。例如：'A'是编码值为65的字符常量。它与“A”不同，“A”是包含一个字符A的字符串。char类型的值可以表示为十六进制值，其范围从\\u0000到\\uFFFF。
### 3.3.4 Unicode和char类型

要想弄清char类型，就必须了解Unicode编码机制。Unicode打破了传统字符编码机制的限制。在Unicode出现之前，已经有许多种不同的标准：美国的ASCII、西欧语言中的ISO 8859-1、俄罗斯的KOI-8、中国的GB 18030和BIG-5等。这样就产生了下面两个问题：一个是`对于任意给定的代码值，在不同的编码方案下有可能对应不同的字母`；二是`采用大字符集的语言其编码长度有可能不同`。例如，有些常用的字符采用单字节编码，而另一些字符则需要两个或多个字节。

设计Unicode编码的目的就是要解决这些问题。在20世纪80年代开始启动统一工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来扩展，当时所有人都这么想。在1991年发布了Unicode 1.0，当时仅占用65536个代码值中不到一半的部分。在设计Java时决定采用16位的Unicode字符集，这比使用8位字符集的其他程序设计语言有了很大的改进。

十分遗憾的是，经过一段时间后，不可避免的事情发生了。Unicode字符超过了65536个，其主要原因是增加了大量的汉语、日语和韩语中的表意文字。现在，16位的char类型已经不能满足描述所有Unicode字符的需要了。

下面利用一些专用术语来解释Java语言从Java 5开始如何解决这个问题。`码点`是指与一个编码表中的某个字符对应的代码值。在Unicode标准中，码点采用十六进制书写，并加上前缀U+，例如U+0041就是拉丁字母A的码点。Unicode的码点可以分成17个`代码平面`。第一个代码平面称为`基本多语言平面`，包括码点从U+0000到U+FFFF的`“经典”Unicode代码`；其余的16个平面的码点为从U+10000到U+10FFFF，包括辅助字符。

UTF-16编码采用不同长度的编码表示所有Unicode码点。在基本多语言平面中，每个字符用16位表示，通常称为`代码单元`；而辅助字符编码为一对连续的代码单元。采用这种编码对表示的各个值落入基本多语言平面中未用的2048个值范围内，通常称为替代区域（U+D800\~U+DBFF用于第一个代码单元，U+DC00\~U+DFFF用于第二个代码单元）。这样的设计十分巧妙，我们可以从中迅速知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。

在Java中，char类型描述了UTF-16编码中的一个代码单元。

我们强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。
### 3.3.5 boolean类型
## 3.4 变量与常量
### 3.4.1 声明变量
### 3.4.2 变量初始化

从Java 10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明类型。只需要使用关键字var而无须指定类型。

```java
var vacationDays = 12;  // vacationDays is an int
var greeting = "Hello"; // greeting is a String
```
### 3.4.3 常量

在Java中，利用关键字final指示常量。关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。吸管刷，常量名使用全大写。

在Java中，经常希望某个常量可以在一个类的多个方法中使用，通常将这些常量称为类常量。可以使用关键字static final设置一个类常量。
### 3.4.4 枚举类型
## 3.5 运算符
### 3.5.1 算术运算符

整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大和NaN结果。

可移植性是Java语言的设计目标之一。无论在哪个虚拟机上运行，同一运算应该得到同样的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double类型使用64位存储一个数值，而有些处理器则使用80位浮点处理器。这些寄存器增加了中间过程的计算精度。例如，以下运算：

```java
double w = x * y / z;
```

很多Intel处理器计算x \* y，并且将结果存储在80位的寄存器中，再除以z并将结果截断为64位。这样可以得到一个更加精确的计算结果，并且还能够避免产生指数溢出。但是，这个结果可能与始终使用64位计算的结果不一样。因此，Java虚拟机的最初规范规定所有的中间结果都必须进行截断。这种做法遭到了数字社区的反对。截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算速度上实际上要比精确计算慢。为此，Java程序设计语言承认了最优性能与理想的可再生性之间存在的冲突，并给予了改进。在默认情况下，现在虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用strictfp关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。

例如，可以把main方法标记为

```java
public static strictfp void main(String[] args)
```

那么，main方法中的所有指令都将使用严格的浮点计算。如果将一个类标记为strictfp，这个类中的所有方法都要使用严格的浮点计算。
### 3.5.2 数学函数与常量

Math类提供了一些方法使整数有更好的运算安全性。如果一个计算溢出，数学运算符只是悄悄地返回错误的结果而不做任何提醒。例如，10亿乘以3的计算结果将是-1294967296，因为最大的int值也只是刚刚超过20亿。不过，如果调用Math.multiplyExact(1000000000, 3)，就会生成一个异常。你可以捕获这个异常或者让程序终止，而不是允许它给出一个错误的结果然后悄无声息地继续运行。另外还有一些方法（addExact、substractExact、incrementExact、decrementExact和negateExact）也可以正确地处理int和long参数。
### 3.5.3 数值类型之间的转换

当用一个二元运算符连接两个值时，先要将两个操作数转换为同一种类型，然后再进行计算。

（1）如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。

（2）否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。

（3）否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。

（4）否则，两个操作数都将被转换为int类型。
### 3.5.4 强制类型转换
### 3.5.5 结合赋值和运算符

如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换。例如，如果x是一个int，则以下语句

```java
x += 3.5;
```

是合法的，将把x设置为(int)(x + 3.5)。
### 3.5.6 自增与自减运算符
### 3.5.7 关系和boolean运算符
### 3.5.8 位运算符

应用在布尔值上时，\&和\|运算符也会得到一个布尔值。这些运算符与\&\&和\|\|运算符很类似，不过\&和\|运算符不采用“短路”方式来求值，也就是说，得到计算结果之前两个操作数都需要计算。

移位运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）。例如，1<<35的值等同于1<<3。
### 3.5.9 括号与运算符级别
## 3.6 字符串
### 3.6.1 子串
### 3.6.2 拼接

如果需要把多个字符串放在一起，用一个界定符分隔，可以使用静态join方法：

```java
String all = String.join(" / ", "S", "M", "L", "XL");  // "S / M / L / XL"
```

在Java 11中，还提供了一个repeat方法：

```java
String repeated = "Java".repeat(3); // "JavaJavaJava"
```
### 3.6.3 不可变字符串

不可变字符串的优点：编译器可以让字符串`共享`。

为了弄清具体的工作方式，可以想象将各种字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。

Java的设计者认为共享带来的高效率远远胜过于提取子串、拼接字符串所带来的低效率。
### 3.6.4 检测字符串是否相等

一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否存放在同一个位置上。当然，如果字符串在同一个位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串副本放置在不同的位置上。

如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。但实际上`只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享`。
### 3.6.5 空串与null
### 3.6.6 码点与代码单元

Java字符串由char值序列组成。char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元。最常用的Unicode字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。

length方法将返回采用UTF-16编码表示给定字符串所需的代码单元数量。例如：

```java
String greeting = "Hello";
int n = greeting.length();  // 5
```

要想得到实际的长度，即码点数量，可以调用：

```java
int cpCount = greeting.codePointCount(0, greeting.length());
```

调用s.charAt(n)将返回位置n的代码单元，n介于0\~s.length() - 1之间。例如：

```java
char first = greeting.charAt(0);  // 'H'
char last = greeting.charAt(4); // 'o'
```

要想得到第i个码点，应该使用下列语句：

```java
int index = greeting.offsetByCodePoints(0, i);
int cp = greeting.codePointAt(index);
```

为什么会对代码单元如此大惊小怪？请考虑以下语句：

```
𝕆 is the set of octonions.
```

使用UTF-16编码表示字符𝕆（U+1D546）需要两个代码单元。调用

```java
char ch = sentence.charAt(1);
```

返回的不是一个空格，而是𝕆的第二个代码单元。为了避免这个问题，不要使用char类型。这太底层了。

如果想要遍历一个字符串，并且一次查看每一个码点，可以使用下列语句：

```java
int cp = sentence.codePointAt(i);
if (Character.isSupplementartCodePoint(cp)) {
    i += 2;
} else {
    i++;
}
```

可以使用下列语句实现反向遍历：

```java
i--;
if (Character.isSurrogate(sentence.charAt(i))) {
    i--;
}
int cp = sentence.codePointAt(i);
```

显然，这很麻烦。更容易的办法是使用codePoints方法，它会生成一个int值的“流”，每个int值对应一个码点。可以将它转换为一个数组，再完成遍历。

```java
int[] codePoints = str.codePoints().toArray();
```

反之，要把一个码点数组转换为一个字符串，可以使用构造器。

```java
String str = new String(codePoints, 0, codePoints.length);
```

虚拟机不一定把字符串实现为代码单元序列。在Java 9中，只包含单字节代码单元的字符串使用byte数组实现，所有其他字符串使用char数组。
### 3.6.7 String API
### 3.6.8 阅读联机API文档
### 3.6.9 构建字符串

有些时候，需要由较短的字符串构建字符串，例如，按键或来自文件中的单词。如果采用字符串拼接的方式来达到这个目的，效率会比较低。每次拼接字符串时，都会构建一个新的String对象，既耗时，又浪费空间。使用StringBuilder类就可以避免这个问题的发生。
## 3.7 输入与输出
### 3.7.1 读取输入

```java
public class InputTest {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // get first input
        System.out.print("What is your name? ");
        String name = in.nextLine();

        // get second input
        System.out.print("How old are you? ");
        int age = in.nextInt();

        // display output on console
        System.out.println("Hello, " + name + ". Next year, you'll be " + (age + 1));
    }
}
```

因为输入是可见的，所以Scanner类不适用于从控制台读取密码。Java 6特别引入了Console类来实现这个目的。要想读取一个密码，可以使用下列代码：

```java
Console cons = System.console();  // 如果可以进行交互，就返回一个Console对象通过控制台窗口与用户交互，否则返回null。对于任何一个在控制台窗口启动的程序，都可使用Console对象。否则，是否可用取决于所使用的系统。
String username = cons.readLine("User name: ");
char[] passwd = cons.readPassword("Password: ");
```

为安全起见，返回的密码存放在一个字符数组中，而不是字符串中。在对密码处理完成之后，应该马上用一个填充值覆盖数组元素。

采用Console对象处理输入不如采用Scanner方便。必须每次读取一行输入，而没有能够读取单个单词或数值的方法。
### 3.7.2 格式化输出
### 3.7.3 文件输入与输出

要想读取一个文件，需要构造一个Scanner对象，如下所示：

```java
Scanner in = new Scanner(Path.of("myfile.txt"), StandardCharsets.UTF_8);
```

如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠转义。

在这里指定了UTF-8字符编码，这对于互联网上的文件很常见（不过并不是普遍适用）。读取一个文本文件时，要知道它的字符编码。如果省略字符编码，则会使用运行这个Java程序的机器的“默认编码”。这不是一个好主意，如果在不同的机器上运行这个程序，可能会有不同的表现。

要想写入文件，就需要构造一个PrintWriter对象。在构造器中，需要提供文件名和字符编码：

```java
PrintWriter out = new PrintWriter("myfile.txt", StandardCharsets.UTF_8);
```

如果文件不存在，创建该文件。可以像输出到System.out一样使用print、println以及printf命令。

如果用一个不存在的文件构造一个Scanner，或者用一个无法创建的文件名构造一个PrintWriter，就会产生异常。
## 3.8 控制流程
### 3.8.1 块作用域
### 3.8.2 条件语句
### 3.8.3 循环
### 3.8.4 确定循环
### 3.8.5 多重选择：switch语句

case标签可以是：

（1）类型为char、byte、short或int的常量表达式。

（2）枚举常量。

（3）从Java 7开始，case标签还可以是字符串字面量。
### 3.8.6 中断控制流程的语句
## 3.9 大数

如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中两个很有用的类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger类实现任意精度的整数运算，BigDecimal实现任意精度的浮点数运算。
## 3.10 数组
### 3.10.1 声明数组

在Java中，允许由长度为0的数组。
### 3.10.2 访问数组元素
### 3.10.3 for each循环

有一个简单的方式可以打印数组中的所有值，即利用Arrays类的toString方法。调用Arrays.toString(a)，返回一个包含数组元素的字符串，这些元素包围在中括号内，并用逗号分隔，例如，“\[2,3,5,7,11,13\]”。
### 3.10.4 数组拷贝
### 3.10.5 命令行参数
### 3.10.6 数组排序
### 3.10.7 多维数组

要想快速打印一个二维数组的数据元素列表，可以调用：

```java
System.out.println(Arrays.deepToString(a));
```
### 3.10.8 不规则数组
# 第4章 对象与类
## 4.1 面向对象程序设计概述
### 4.1.1 类
### 4.1.2 对象
### 4.1.3 识别类
### 4.1.4 类之间的关系

如果一个类的方法使用或操纵另一个类的对象，我们就说一个类`依赖`于另一个类。

`聚合`即“has-a”关系。例如，一个Order对象包含一些Item对象。

`继承`即“is-a”关系，表示一个更特殊的类与一个更一般的类之间的关系。
## 4.2 使用预定义类
### 4.2.1 对象与对象变量

对象变量并没有实际包含一个对象，它只是引用一个对象。

在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。new操作符的返回值也是一个引用。
### 4.2.2 Java类库中的LocalDate类

Java类库设计者将保存时间与给时间点命名分开：Date类用来表示时间点；LocalDate用日历表示法表示日期。

不要使用构造器来构造LocalDate类的对象。实际上，应当使用静态工厂方法，它会代表你调用构造器。下面的表达式：

```java
LocalDate.now();
```

会构造一个新对象，表示构造这个对象时的日期。

可以提供年、月和日来构造对应一个特定日期的对象：

```java
LocalDate.of(1999, 12, 31);
```

一旦有了一个LocalDate对象，可以用方法getYear、getMonthValue和getDayOfMonth得到年、月和日。
### 4.2.3 更改器方法与访问器方法
## 4.3 用户自定义类
### 4.3.1 Employee类
### 4.3.2 多个源文件的使用
### 4.3.3 剖析Employee类
### 4.3.4 从构造器开始

（1）构造器与类同名。

（2）每个类可以有一个以上的构造器。

（3）构造器可以有0个、1个或多个参数。

（4）构造器没有返回值。

（5）构造器总是伴随着new操作符一起调用。
### 4.3.5 用var声明局部变量

在Java 10中，如果可以从变量的初始值推导出它们的类型，那么可以用var关键字声明`局部变量`，而无须指定类型。
### 4.3.6 使用null引用
### 4.3.7 隐式参数与显式参数
### 4.3.8 封装的优点

如果需要返回一个可变数据字段的副本，就应该使用clone。
### 4.3.9 基于类的访问权限

一个方法可以访问所属类的所有对象的私有数据。

```java
class Employee {
    private String name;

    public boolean equals(Employee other) {
        return name.equals(other.name);
    }
}
```
### 4.3.10 私有方法
### 4.3.11 final实例字段

可以将实例字段定义为final。这样的字段必须在构造对象时初始化。也就是说，必须确保在每一个构造器执行之后，这个字段的值已经设置，并且以后不能再修改这个字段。

final修饰符对于类型为基本类型或者不可变类的字段尤其有用。（如果类中的所有方法都不会改变其对象，这样的类就是不可变的类。例如，String类就是不可变的。）
## 4.4 静态字段与静态方法
### 4.4.1 静态字段
### 4.4.2 静态常量
### 4.4.3 静态方法

静态方法是没有this参数的方法（在一个非静态的方法中，this参数指示这个方法的隐式参数）。

静态方法不能访问实例字段，因为它不能再对象上执行操作。但是，静态方法可以访问静态字段。

可以使用对象调用静态方法。不过，这种写法很容易造成混淆。建议使用类名而不是对象来调用静态方法。
### 4.4.4 工厂方法

静态工厂方法来构造对象的优点：

（1）可以自定义方法名称。

（2）可以自定义所构造对象的类型。
### 4.4.5 main方法
## 4.5 方法参数

按值调用：方法接收的是调用者提供的值。

按引用调用：方法接收的是调用者提供的变量地址。

方法可以修改按引用传递的变量的值，而不能修改按值传递的变量的值。

`Java总是采用按值调用，方法得到的是所有参数值的一个副本，即方法不能修改传递给它的任何参数变量的内容`。

（1）方法不能修改基本数据类型的参数（即数值型或布尔型）。

（2）方法可以改变对象参数的状态。

（3）方法不能让一个对象参数引用一个新的对象。
## 4.6 对象构造
### 4.6.1 重载

方法的签名：方法名、参数类型以及参数顺序。

返回类型不是方法签名的一部分。不能有两个名字相同，参数类型也相同却有不同返回类型的方法。
### 4.6.2 默认字段初始化

方法中的局部变量必须明确地初始化。但是在类中，如果没有初始化类中的字段，将会自动初始化为默认值（0， false或null）。
### 4.6.3 无参数的构造器

仅当类没有任何其他构造器的时候，才会得到一个默认的无参数构造器。
### 4.6.4 显式字段初始化

可以在类定义中直接为任何字段赋值。例如：

```java
class Employee {
    private String name = "";
}
```

在执行构造器之前先完成这个赋值操作。初始值不一定是常量值：

```java
class Employee {
    private static int nextId;

    private int id = assignId();

    private static int assignId() {
        int r = nextId;
        nextId++;
        return r;
    }
}
```
### 4.6.5 参数名
### 4.6.6 调用另一个构造器

如果构造器的第一个语句形如this(...)，这个构造器将调用同一个类的另一个构造器。
### 4.6.7 初始化块

在一个类的声明中，可以包含任意多个代码块。只要构造这个类的对象，这些块就会被执行。这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。

`可以在初始化块中设置字段，即使这些字段在类后面才定义，这是合法的。但是，为了避免循环定义，不允许读取在后面初始化的字段`。

调用构造器的具体处理步骤：

（1）如果构造器的第一行调用了另一个构造器，则基于所提供的参数执行第二个构造器。

（2）否则，

    a）所有数据字段初始化为其默认值（0、false或null）。

    b）按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块。

（3）执行构造器主体代码。

在类第一次加载的时候，将会进行静态字段的初始化。与实例字段一样，除非将静态字段显式地设置成其他值，否则默认的初始值是0、false或null。所有的静态字段初始化方法以及静态初始化块都将依照类声明中出现的顺序执行。
### 4.6.7 对象析构与finalize方法

如果一个资源一旦使用完就需要立即关闭，那么应当提供一个close方法来完成必要的清理工作。可以在对象使用完时调用这个close方法。

如果可以等到虚拟机退出，那么可以用方法Runtime.addShutdownHook增加一个“关闭钩”。在Java 9中，可以使用Cleaner类注册一个动作，当对象不再可达时，就会完成这个动作。

`不要使用finalize方法来完成清理。这个方法原本要在垃圾回收器清理对象之前调用。不过，你并不能知道这个方法到底什么时候调用，而且该方法已经被废弃。`
## 4.7 包
### 4.7.1 包名

从编译器的角度来看，嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个包都是独立的类集合。
### 4.7.2 类的导入

只能使用星号（\*）导入一个包，而不能使用import.java.\*或import.java.\*.\*导入以java为前缀的所有包。

在包中定位类是编译器的工作。类文件中的字节码总是使用完整的包名引用其他类。
### 4.7.3 静态导入
### 4.7.4 在包中增加类

编译器在编译源文件的时候不检查目录结构。例如，假定一个源文件开头有以下指令：

```
package com.mycompany
```

即使这个源文件不在子目录com/mycompany下，也可以进行编译。如果它不依赖于其他包，就可以通过编译而不会出现编译错误。但是，最终的程序将无法运行，除非先将所有类文件移到正确的位置上。如果包与目录不匹配，虚拟机就找不到类。
### 4.7.5 包访问
### 4.7.6 类路径

JAR文件使用ZIP格式组织文件和子目录。可以使用任何ZIP工具查看JAR文件。

javac编译器总是在当前的目录中查找文件，但java虚拟机仅在类路径中包含“.”目录的时候才查看当前目录。如果没有设置类路径，那么没有什么问题，因为默认的类路径会包含“.”目录。但是如果你设置了类路径却忘记包含“.”目录，那么尽管你的程序可以没有错误地通过编译，但不能运行。

编译器查找文件要比虚拟机复杂得多。如果引用了一个类，而没有指定这个类的包，那么编译器将首先查找包含这个类的包。它会查看所有的import指令，确定其中是否包含这个类。例如，假定源文件包含指令：

```
import java.util.*;
import com.horstmann.corejava.*
```

并且源代码引用了Employee类。编译器将尝试查找java.lang.Employee（因为java.lang包总是会默认导入）、java.util.Employee、com.horstmann.corejava.Employee和当前包中的Employee。它会在类路径所有位置中搜索以上各个类。如果找到了一个以上的类，就会产生编译时错误（因为完全限定类名必须是唯一的，所以import语句的次序并不重要）。

编译器的任务不止这些，它还要查看源文件是否比类文件新。如果是这样的话，那么源文件就被自动地重新编译。
### 4.7.7 设置类路径

最好使用-classpath选项指定类路径：

```
java -classpath c:\classdir;.;c:\archives\archive.jar MyProg
```
## 4.8 JAR文件

在将应用程序打包时，你一定希望只向用户提供一个单独的文件，而不是一个包含大量类文件的目录结构，Java归档（JAR）文件就是为此目的而设计的。一个JAR文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件。此外，JAR文件是压缩的，它使用了我们熟悉的ZIP压缩格式。
### 4.8.1 创建JAR文件

```
jar cvf jarFileName file1 file2 ...
```
### 4.8.2 清单文件

除了类文件、图像和其他资源外，每个JAR文件还包含一个清单文件（manifest），用于描述归档文件的特殊特性。

清单文件被命名为MANIFEST.MF，它位于JAR文件的一个特殊的META-INF子目录中。符合标准的最小清单文件极其简单：

```
Manifest-Version: 1.0
```

复杂的清单文件可能包含更多条目。这些清单条目被分成多个节。第一节被称为主节（main section）。它作用于整个JAR文件。随后的条目用来指定命名实体的属性，如单个文件、包或者URL。它们都必须以一个Name条目开始。节与节之间用空行分开。例如：

```
Manifest-Version: 1.0
lines describing this archive

Name: Woozle.class
lines describing this file
Name: com/mycompany/mypkg/
lines describing this package
```

要想编辑清单文件，需要将希望添加到清单文件中的行放到文本文件中，然后运行：

```
jar cfm jarFileName manifestFileName ...
```

例如，要创建一个包含清单文件的JAR文件，应该运行：

```
jar cfm MyArchive.jar manifest.mf com/mycompany/mypkg/*.class
```

要想更新一个已有的JAR文件的清单，则需要将增加的部分放置到一个文本文件中，然后执行以下命令：

```
jar ufm MyArchive.jar manifest-additions.mf
```
### 4.8.3 可执行JAR文件

可以使用jar命令中的e选项指定程序的入口点，即通常需要在调用java程序启动器时指定的类：

```
java cvfe MyProgram.jar com.mycompany.mupkg.MainAppClass files to add
```

用户可以简单地通过下面的命令来启动程序：

```
java -jar MyProgram.jar
```
### 4.8.4 多版本JAR文件

Java 9引入了多版本JAR，其中可以包含面向不同Java版本的类文件。

为了保证向后兼容，额外的类文件放在META-INF/versions目录中。Java 8完全不知道META-INF/versions目录，它只会加载遗留的类。Java 9读取这个JAR文件时，则会使用新版本。

要增加不同版本的类文件，可以使用--release标志：

```
jar uf MyProgram.jar --release 9 Application.class
```

要从头构建一个多版本JAR文件，可以使用-C选项，对应每个版本要切换到一个不同的类文件目录：

```
jar cf MyProgram.jar -C bin/8 . --release 9 -C bin/9 Application.class
```

面向不同版本编译时，要使用--release标志和-d标志来指定输出目录：

```
javac -d bin/8 --release 8 ...
```
### 4.8.5 关于命令行选项的说明
## 4.9 文档注释
### 4.9.1 注释的插入
### 4.9.2 类注释
### 4.9.3 方法注释
### 4.9.4 字段注释
### 4.9.5 通用注释
### 4.9.6 包注释
### 4.9.7 注释抽取

在这里，假设你希望HTML文件将放在名为docDirectory的目录下。执行以下步骤：

（1）切换到包含想要生成文档的源文件的目录。如果有嵌套的包要生成文档，例如com.horstmann.corejava，就必须切换到包含子目录com的目录。

（2）如果是一个包，应该运行命令：

```
javadoc -d docDirectory nameOfPackage
```

或者，如果要为多个包生成文档，运行：

```
javadoc -d docDirectory nameOfPackage1 nameOfPackage2 ...
```

如果文件在无名的包中，就应该运行：

```
javadoc -d docDirectory *.java
```

如果省略了-d docDirectory选项，那HTML文件就会被提取到当前目录下。这样有可能会带来混乱，因此不提倡这种做法。

-link选项可以用来为标准类添加超链接：

```
javadoc -link http://docs.oracle.com/javase/9/docs/api *.java
```

那么，所有的标准类库类都会自动地链接到Oracle网站的文档。
## 4.10 类设计技巧

（1）一定要保证数据私有。

（2）一定要对数据进行初始化。

（3）不要在类中使用过多的基本类型。

要用其他的类替换使用多个相关的基本类型。这样会使类更易于理解，也更易于修改。例如，用一个名为Address的新类替换一个Customer类中以下的实例字段：

```java
private String street;

private String city;

private String state;

private int zip;
```

这样一来，可以很容易地处理地址的变化，例如，可能需要处理国际地址。

（4）不是所有的字段都需要单独的字段访问器和字段更改器。

（5）分解有过多职责的类。

（6）类名和方法名要能够体现它们的职责。

（7）优先使用不可变类。
# 第5章 继承
## 5.1 类、超类和子类
### 5.1.1 定义子类
### 5.1.2 覆盖方法

有些人认为super与this引用是类似的概念，实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，例如，不能将值super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。
### 5.1.3 子类构造器

使用super调用构造器的语句必须是子类构造器的第一条语句。

如果子类的构造器没有显式地调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，Java编译器就会报告一个错误。

关键字this有两个含义：一是指示隐式参数的引用，二是调用该类的其他构造器。

关键字super也有两个含义：一是调用超类的方法，二是调用超类的构造器。

在调用构造器的时候，this和super这两个关键字紧密相关。调用构造器的语句只能作为另一个构造器的第一条语句出现。构造器参数可以传递给当前类（this）的另一个构造器，也可以传递给超类（super）的构造器。

一个对象变量可以指示多种实际类型的现象称为`多态`。在运行时能够自动地选择适当的方法，称为`动态绑定`。
### 5.1.4 继承层次
### 5.1.5 多态

在Java中，子类引用的数组可以转换成超类引用的数组，而不需要使用强制类型转换。例如，下面是一个经理数组：

```java
Manager[] managers = new Manager[10];
```

将它转换成Employee[]数组完全是合法的：

```java
Employee[] staff = managers;  // OK
```

这样做肯定不会有问题。毕竟，如果manager[i]是一个Manager，它也一定是一个Employee。不过，实际上将会发生一些令人惊讶的事情。要切记managers和staff引用的是同一个数组。现在看一下这条语句：

```java
staff[0] = new Employee("Harry Hacker", ...);
```

编译器竟然接纳了这个赋值操作。但在这里，staff[0]与manager[0]是相同的引用，我们把一个普通员工擅自归入经历行列了，将会在运行时引发ArrayStoreException异常。
### 5.1.6 理解方法调用

假设要调用x.f(args)，隐式参数x声明为类C的一个对象，下面是调用过程的详细描述：

（1）编译器查看对象的声明类型和方法名。需要注意的是：有可能存在多个名字为f但参数类型不一样的方法。例如，可能存在方法f(int)和方法f(String)。编译器将会一一列举`C类中所有名为f的方法`和`其超类中所有名为f而且可访问的方法（超类的私有方法不可访问）`。

至此，编译器已经知道所有可能被调用的候选方法。

（2）接下来，编译器要确定方法调用中提供的参数类型。如果在所有名为f的方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法。这个过程称为`重载解析`。例如，对于调用x.f("Hello")，编译器将会挑选f(String)，而不是f(int)。由于允许类型转换（int可以转换成double，Manager可以转换成Employee），所以情况可能会变得很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，编译器就会报告一个错误。

至此，编译器已经知道需要调用的方法的名字和参数类型。

>> 返回类型不是方法签名的一部分。不过在覆盖一个方法时，需要保证返回类型的兼容性。允许子类将覆盖方法的返回类型改为原返回类型的子类型。

（3）如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法。这称为`静态绑定`。如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用`动态绑定`。

（4）程序运行并且采用动态绑定调用方法时，虚拟机必须调用与x所引用对象的实际类型对应的那个方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就会调用这个方法；否则，将在D的超类中寻找f(String)，以此类推。

每次方法调用都要完成这个搜索，时间开销相当大。因此，虚拟机预先为每个类计算了一个`方法表`，其中列出了所有方法的签名和要调用的实际方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中，虚拟机搜索D类的方法表，寻找与调用f(String)相匹配的方法。这个方法既有可能是D.f(String)，也有可能是X.f(String)，这里的X是D的某个超类。这里需要提醒一点，`如果调用时super.f(param)，那么编译器将对隐式参数超类的方法表进行搜索`。

>> 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法必须也要声明为public。
### 5.1.7 阻止继承：final类和方法

不允许扩展的类被称为final类。

类中的某个特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地成为final方法）。

>> 字段也可以声明为final。对于final字段来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为final，只有其中的方法自动地成为final，而不包括字段。

在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程称为`内联`。例如，内联调用e.getName()将被替换为访问字段e.name。这是一项很有意义的改进，CPU在处理当前指令时，分支会扰乱预取指令的策略，所以，CPU不喜欢分支。然而，如果getName在另外一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。

幸运的是，虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出是否有类确实覆盖了给定的方法。如果方法很简短、被频繁调用而且确实没有被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而这个子类覆盖了一个内联方法，优化器将取消这个方法的内联。这个过程很慢，不过很少会发生这种情况。
### 5.1.8 强制类型转换

（1）只能在继承层次内进行强制类型转换。

（2）在将超类强制转换成子类之前，应该使用instanceof进行检查。

>> 如果x为null，x instanceof C不会产生异常，只是返回false。之所以这样处理是因为null没有引用任何对象，当然也不会引用C类型的对象。
### 5.1.9 抽象类

包含一个或多个抽象方法的类本身必须被声明为抽象的。

抽象方法充当着占位方法的角色，它们在子类中具体实现。扩展抽象类可以有两种选择。一种是在子类中保留抽象类中的部分或所有抽象方法仍未定义，这样就必须将子类也标记为抽象类；另一种做法是定义全部方法，这样一来，子类就不是抽象的了。
### 5.1.10 受保护访问

（1）仅对本类可见——private。

（2）对外部完全可见——public。

（3）对本包和所有子类可见——protected。

（4）对本包可见——默认，不需要修饰符。
## 5.2 Object：所有类的超类
### 5.2.1 Object类型的变量

所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。
### 5.2.2 equals方法

Objects.equals方法的逻辑：如果两个参数都为null，Objects.equals(a, b)调用将返回true；如果其中一个参数为null，则返回false；否则，如果两个参数都不为null，则调用a.equals(b)。
### 5.2.3 相等测试与继承

Java语言规范要求equals方法具有下面的特性：

（1）`自反性`：对于任何非空引用x，x.equals(x)应该返回true。

（2）`对称性`：对于任何引用x和y，当且仅当y.equals(x)返回true时，x.equals(y)返回true。

（3）`传递性`：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true。

（4）`一致性`：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果。

（5）对于任意非空引用x，x.equals(null)应该返回false。

如果子类可以有自己的相等性概念，则对称性需求将强制使用getClass检测。如果由超类决定相等性概念，那么就可以使用instanceof检测，这样可以在不同子类的对象之间进行相等性比较。
### 5.2.4 hashCode方法

字符串的散列码是由内容导出的。

如果重新定义了equals方法，就必须为用户可能插入散列表的对象重新定义hashCode方法。

equals与hashCode的定义必须相容：如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()返回相同的值。
### 5.2.5 toString方法

只要对象与一个字符串通过操作符“+”连接起来，Java编译器就会自动地调用toString方法来获得这个对象的字符串描述。

>> 可以不写为x.toString()，而写作""+x。这条语句将一个空串与x的字符串表示（也就是x.toString()）相连接。与toString不同的是，即使x是基本类型，这条语句照样能够执行。

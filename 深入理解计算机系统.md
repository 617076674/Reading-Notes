# 第1章 计算机系统漫游

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```
## 1.1 信息就是位+上下文

hello程序的生命周期是从一个`源程序`（或者说`源文件`）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是hello.c。源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为`字节`。每个字节表示程序中的某些文本字符。

像hello.c这样只由ASCII字符构成的文件称为`文本文件`，所有其他文件都称为`二进制文件`。

系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。
## 1.2 程序被其他程序翻译成不同的格式

hello程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行hello.c程序，每条C语句都必须被其他程序转化为一系列的低级`机器语言`指令。然后这些指令按照一种称为`可执行目标程序`的格式打好包，并以`二进制磁盘文件`的形式存放起来。目标程序也称为`可执行目标文件`。

在Unix系统上，从源文件到目标文件的转化是由`编译器驱动程序`完成的：

```
linux> gcc -o hello hello.c
```

在这里，GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。这个翻译过程可分为四个阶段完成。执行这四个阶段的程序（`预处理器`、`编译器`、`汇编器`和`链接器`）一起构成了`编译系统`。

（1）`预处理阶段`。预处理器根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的#include \<stdio.h\>命令告诉预处理器读取头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序hello.i。

（2）`编译阶段`。编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含函数main的定义，如下所示：

```
1  main:
2   subq    $8, %rsp
3   movl    $.LCO, %edi
4   call    puts
5   movl    $0, %eax
6   addq    $8, %rsp
7   ret
```

定义中2\~7行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。

（3）`汇编阶段`。接下来，汇编器将hello.s翻译成机器语言指令，把这些指令打包成一种叫做`可重定位目标程序`的格式，并将结果保存在目标文件hello.o中。hello.o是一个二进制文件，它包含的17个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。

（4）`链接阶段`。hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器就负责处理这种合并。结果就得到hello文件，它是一个`可执行目标文件`（或者简称为`可执行文件`），可以被加载到内存中，由系统执行。
## 1.3 了解编译系统如何工作是大有益处的

（1）`优化程序性能`。现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在C程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C语句转化为机器代码的方式。比如，`一个switch语句是否总是比一系列的if-else语句高效得多`？`一个函数调用的开销有多大`？`while循环比for循环更有效吗`？`指针引用比数组索引更有效吗`？`为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢`？`为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快`？

（2）`理解链接时出现的错误`。一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，`链接器报告说它无法解析一个引用，这是什么意思`？`静态变量和全局变量的区别是什么`？`如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么`？`静态库和动态库的区别是什么`？`我们在命令行上排列库的顺序有什么影响`？最严重的是，`为什么有些链接错误直到运行时才会出现`？

（3）`避免安全漏洞`。多年来，缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解`需要限制从不受信任的源接收数据的数量和格式`。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。
## 1.4 处理器读并解释储存在内存中的指令

shell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。
### 1.4.1 系统的硬件组成

（1）总线

`总线`是贯穿整个系统的一组电子管道，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是`字`。字中的字节数（即`字长`）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32位），要么是8个字节（64位）。

（2）I/O设备

每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。`控制器`是I/O设备本身或者系统的主印制电路板（通常称作`主板`）上的`芯片组`。而`适配器`则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。

（3）主存

`主存`是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组`动态随机存取存储器`（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。比如，在运行Linux的x86-64机器上，short类型的数据需要2个字节，int和float类型需要4个字节，而long和double类型需要8个字节。

（4）处理器

中央处理单元（CPU），简称`处理器`，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为`程序计数器`（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由`指令集架构`决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。

这样的简单操作并不多，它们围绕着`主存`、`寄存器文件`和`算术/逻辑单元`（ALU）进行。`寄存器文件`是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作。

1）`加载`：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。

2）`存储`：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。

3）`操作`：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。

4）`跳转`：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值。

处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：`指令集架构`描述的是每条机器代码指令的效果；而`微体系结构`描述的是处理器实际上是如何实现的。
### 1.4.2 运行hello程序

初始时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串”./hello"后，shell程序将字符逐一读入寄存器，再把它存放到内存中。

当我们在键盘上敲回车时，shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello, world\\n”。

利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。

一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将“hello, world\\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。
## 1.5 高速缓存至关重要

位于处理器芯片上的`L1高速缓存`的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的`L2高速缓存`通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5\~10倍。L1和L2的高速缓存是用一种叫做`静态随机访问存储器`（SRAM）的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：L1、L2和L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的`局部性原理`，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。
## 1.6 存储设备形成层次结构

存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，`寄存器文件就是L1的高速缓存`，`L1是L2的高速缓存`，`L2是L3的高速缓存`，`L3是主存的高速缓存`，而`主存又是磁盘的高速缓存`。`在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存`。
## 1.7 操作系统管理硬件

操作系统有两个基本功能：（1）防止硬件被失控的应用程序滥用。（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（`进程`、`虚拟内存`和`文件`）来实现这两个功能。`文件是对I/O设备的抽象表示`，`虚拟内存是对主存和磁盘I/O设备的抽象表示`，`进程则是对处理器、主存和I/O设备的抽象表示`。
### 1.7.1 进程

`进程`是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数多于可以运行它们的CPU个数。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为`上下文切换`。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行`上下文切换`，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

最开始，只有shell进程在运行，即等待命令行上的输入。当我们让它运行hello程序时，shell通过调用一个专门的函数，即`系统调用`，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传给新的hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给它，shell进程会继续等待下一个命令行输入。

从一个进程到另一个进程的转换是由操作系统`内核`管理的，内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的`系统调用`指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。`内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合`。
### 1.7.2 线程

一个进程可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。
### 1.7.3 虚拟内存

`虚拟内存`是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为`虚拟地址空间`。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样的。地址空间的底部区域存放用户进程定义的代码和数据。

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。从最低的地址开始：

（1）`程序代码和数据`。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件hello的内容初始化的。

（2）`堆`。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。

（3）`共享库`。大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。

（4）`栈`。位于用户虚拟地址空间顶部的是`用户栈`，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。

（5）`内核虚拟内存`。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是`把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存`。
### 1.7.4 文件

`文件`就是`字节序列`。每个I/O设备，包括磁盘、键盘、显示器、甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为`Unix I/O`的`系统函数调用`读写文件来实现的。

`文件`这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备。例如，处理磁盘文件内容的应用程序员无须了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。
## 1.8 系统之间利用网络通信

从一个单独的系统来看，网络可视为一个I/O设备。
## 1.9 重要主题
### 1.9.1 Amdahl定律

当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。
### 1.9.2 并发和并行

术语`并发`（concurrency）是一个通用的概念，指一个同时具有多个活动的系统；而术语`并行`（parallelism）指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。

（1）线程级并发

构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。

`多核处理器`是将多个CPU（称为“核”）集成到一个集成电路芯片上。

`超线程`，有时称为`同时多线程`，是一项`允许一个CPU执行多个控制流`的技术。它涉及CPU某些硬件有多个备份，比如`程序计数器`和`寄存器文件`，而其他的硬件部分只有一份，比如`执行浮点算术运算的单元`。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。

多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。

（2）指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为`指令级并行`。在`流水线`中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些步骤可以并行地操作，用来处理不同指令的不同部分。

如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为`超标量处理器`。大多数现代处理器都支持超标量操作。

（3）单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为`单指令、多数据`，即`SIMD并行`。例如，较新几代的Intel和AMD处理器都具有并行地对8对单精度浮点数（C数据类型float）做加法的指令。

提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从C程序中自动抽取SIMD并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序。
### 1.9.3 计算机系统中抽象的重要性

在处理器里，`指令集架构`提供了对实际处理器硬件的抽象。`文件`是对I/O设备的抽象。`虚拟内存`是对程序存储器（主存和I/O设备）的抽象。`进程`是对一个正在运行的程序的抽象。`虚拟机`是对整个计算机的抽象，包括操作系统、处理器和程序。
## 1.10 小结
# 第2章 信息的表示和处理

`无符号编码`基于传统的二进制表示法，表示大于或者等于零的数字。`补码编码`是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的整数。`浮点数编码`是表示实数的科学记数法的以2为基数的版本。

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会`溢出`。溢出会导致某些令人吃惊的后果。例如，在今天的大多数计算机上（使用32位来表示数据类型int），计算表达式200 * 300 * 400 * 500会得出结果-884901888。这违背了整数运算的特性，计算一组正数的乘积不应产生一个负的结果。

另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利用乘法的结合律和交换律，计算下面任何一个C表达式，都会得出结果-884901888：

(500 \* 400) \* (300 \* 200)
((500 \* 400) \* 300) \* 200
((200 \* 500) \* 300) \* 400
400 \* (200 \* (300 \* 500))

计算机可能没有产生期望的结果，但是至少它是一致的！

浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值+∞，但是一组正数的乘积总是正的。`由于表示的精度有限，浮点运算是不可结合的`。例如，在大多数的机器上，C表达式(3.14+1e20)-1e20求得的值会是0.0，而3.14+(1e20-1e20)求得的值会是3.14。整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不同——`整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的`。
## 2.1 信息存储

大多数计算机使用8位的块，或者`字节`，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为`虚拟内存`。内存的每个字节都由一个唯一的数字来标识，称为它的`地址`，所有可能地址的集合就称为`虚拟地址空间`。这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

C语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是`某个存储块的第一个字节的虚拟地址`。`C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息`。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。
### 2.1.1 十六进制表示法
### 2.1.2 字数据大小

每台计算机都有一个`字长`，指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，所以`字长决定的最重要的系统参数就是虚拟地址空间的最大大小`。也就是说，对于一个字长为w位的机器而言，虚拟地址的范围为0\~2^w - 1，程序最多访问2^w个字节。

我们将程序称为”32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。
### 2.1.3 寻址和字节顺序

多字节对象都被存储为连续的字节序列，对象的地址为所使用细节中最小的地址。例如，假设一个类型为int的变量x的地址为0x100，也就是说，地址表达式&x的值为0x100。那么，（假设数据类型int为32位表示）x的4个字节将被存储在内存的0x100、0x101、0x102和0x103位置。

`小端法`：在内存中按照从最低有效字节到最高有效字节的顺序存储对象。`大端法`：按照从最高有效字节到最低有效字节的顺序存储。

大多数Intel兼容机都只用小端模式。另一方面，IBM和Oracle的大多数机器则是按大端模式操作。许多比较新的微处理器是`双端法`，也就是说可以把它们配置成作为大端或者小端的机器运行。然而，实际情况是：一旦选择了特定操作系统，那么字节顺序也就固定下来。比如，用于许多移动电话的ARM微处理器，其硬件可以按小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统——Android和iOS——却只能运行于小端模式。

当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。
### 2.1.4 表示字符串

C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都由某个标准编码来标识，最常见的是ASCII字符码。在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，`文本数据比二进制数据具有更强的平台独立性`。

UTF-8表示将每个字符编码为一个字节序列，这样标准ASCII字符还是使用和它们在ASCII中一样的单字节编码，这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的。
### 2.1.5 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此`二进制文件是不兼容的`。二进制代码很少能在不同机器和操作系统组合之间移植。

从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。
### 2.1.6 布尔代数简介

```
a & (b | c) = (a & b) | (a & c)

a | (b & c) = (a | b) & (a | c)

a ^ a = 0

(a ^ b) ^ a = b
```
### 2.1.7 C语言中的位级运算

表达式\~0将生成一个全1的掩码，不管机器的字大小是多少。尽管对于一个32位机器来说，同样的掩码可以写成0xFFFFFFFF，但是这样的代码不是可移植的。
### 2.1.8 C语言中的逻辑运算

逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。它们返回1或者0，分别表示结果为TRUE或者为FALSE。

逻辑运算&&和||与它们对应的位级运算&和|之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。例如，表达式a&&5/a将不会造成被零除，而表达式p&&\*p++也不会导致间接引用空指针。
### 2.1.9 C语言中的移位运算

x<<k：x向左移动k位，丢弃最高的k位，并在右端补k个0。

x>>k：（1）逻辑右移，在左端补k个0；（2）算术右移：在左端补k个最高有效位的值。C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以。但几乎所有的编译器/机器组合都对有符号数使用算术右移。
## 2.2 整数表示
### 2.2.1 整型数据类型
### 2.2.2 无符号数的编码
### 2.2.3 补码编码

C语言标准并没有要求要用补码形式来标识有符号整数，但是几乎所有的机器都是这么做的。
### 2.2.4 有符号数和无符号数之间的转换

对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：`数值可能会改变，但是位模式不变`。
### 2.2.5 C语言中的有符号数和无符号数

当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。
### 2.2.6 扩展一个数字的位表示

零扩展：在开头添加0；符号扩展：在开头添加最高有效位的值。

从一个数据大小到另一个数据大小的转换，以及无符号和有符号数字之间的转换的相对顺序能够影响一个程序的行为。当把short转换成unsigned时，我们先要改变大小，之后再完成从有符号到无符号的转换。也就是说(unsigned) sx等价于(unsigned) (int) sx，求值得到4294954951，而不等价于(unsigned) (unsigned short) sx，后者求值得到53191。
### 2.2.7 截断数字
### 2.2.8 关于有符号数与无符号数的建议
## 2.3 整数运算
### 2.3.1 无符号加法
### 2.3.2 补码加法

两个数的w位补码之和与无符号之和有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。
### 2.3.3 补码的非

执行位级补码非的第一种方法是对每一位求补，再对结果加1。

计算一个数x的补码非的第二种方法是建立在将位向量分为两部分的基础之上的。假设k是最右边的1的位置，因而x的位级表示形如\[x(w - 1), x(w - 2), ..., x(k + 1), 1, 0, ...0\]。（只要x≠0就能够找到这样的k。）这个值的非写成二进制格式就是\[\~x(w - 1), \~x(w - 2), ..., \~x(k + 1), 1, 0, ..., 0\]。也就是，我们对位k左边的所有位取反。
### 2.3.4 无符号乘法
### 2.3.5 补码乘法

对于无符号和补码乘法来说，乘法运算的位级表示都是一样的。
### 2.3.6 乘以常数

在大多数机器上，整数乘法指令相当慢，需要10个或者更多的时钟周期，然而其他整数运算（例如加法、减法、位级运算和移位）只需要1个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。

考虑一个任务，对于某个常数K的表达式x\*K生成代码。编译器会将K的二进制表示表达为一组0和1交替的序列。例如，14可以写成\[(0...0)(111)(0)\]。考虑一组从位位置n到位位置m的连续的1（n >= m）。（对于14来说，我们有n = 3和m = 1。）我们可以用下面两种不同形式中的一种来计算这些位对乘积的影响：

形式A：(x << n) + (x << (n - 1)) + ... + (x << m)
形式B：(x << (n + 1)) - (x << m)

把每个这样连续的1的结果加起来，不用做任何乘法，我们就能计算出x \* K。当然，选择使用移位、加法和减法的组合，还是使用一条乘法指令，取决于这些指令的相对速度，而这些是与机器高度相关的。大多数编译器只在需要少量移位、加法和减法就足够的时候才使用这种优化。
### 2.3.7 除以2的幂

在大多数机器上，整数除法要比整数乘法更慢——需要30个或者更多的时钟周期。除以2的幂也可以用移位运算来实现，只不过我们用的是右移，而不是左移。无符号和补码数分别使用逻辑移位和算术移位来达到目的。
### 2.3.8 关于整数运算的最后思考

计算机执行的“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或者非常类似的位级行为。
## 2.4 浮点数
### 2.4.1 二进制小数
### 2.4.2 IEEE浮点表示

IEEE浮点标准用V = ((-1) ^ s) × M × (2 ^ E)的形式来表示一个数：

（1）符号：s决定这数是负数（s = 1）还是正数（s = 0），而对于数值0的符号位解释作为特殊情况处理。

（2）尾数：M是一个二进制小数，它的范围是1\~2-ε，或者是0\~1-ε。

（3）阶码：E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。

将浮点数的位表示划分为三个字段，分别对这些值进行编码：

（1）一个单独的符号为s直接编码符号s。

（2）k位的阶码字段exp = e(k - 1)...e(1)e(0)编码阶码E。

（3）n位小数字段frac = f(n - 1)...f(1)f(0)编码尾数M，但是编码出来的值也依赖于阶码字段的值是否等于0。

在单精度浮点格式（C语言中的float）中，s、exp和frac字段分别为1位、k = 8位和n = 23位，得到一个32位的表示。

```
31 30         23 22           0
s |     exp     |     frac     |
```

在双精度浮点格式（C语言中的double）中，s、exp和frac字段分别为1位、k = 11位和n = 52位，得到一个64位的表示。

```
63 62         52 51           0
s |     exp     |     frac     |
```

给定位表示，根据exp的值，被编码的值可以分成三种不同的情况（最后一种情况有两个变种）。以单精度格式进行说明：

（1）规格化的

```
s |     ≠0&≠255     |     frac     |
```

这是最普遍的情况。当exp的位模式既不全为0（数值0），也不全为1（单精度数值为255，双精度数值为2047）时，都属于这类情况。在这种情况中，阶码字段被解释为以`偏置`形式表示的有符号整数。也就是说，阶码的值是E = e - Bias，其中e是无符号数，其位表示为e(k - 1)...e(1)e(0)，而Bias是一个等于2 ^ (k - 1) - 1（单精度是127，双精度是1023）的偏置值。由此产生指数的取值范围，对于单精度是-126\~+127，而对于双精度是-1022\~+1023。

小数字段frac被解释为描述小数值f，其中0 <= f < 1，其二进制表示为0.f(n - 1)...f(1)f(0)，也就是二进制小数点在最高有效位的左边。尾数定义为M = 1 + f。有时，这种方式也叫作`隐含的以1开头的表示`，因为我们可以把M看成一个二进制表达式为1.f(n - 1)f(n - 2)...f(0)的数字。既然我们总是能够调整阶码E，使得尾数M在范围1 <= M < 2之中（假设没有溢出），那么这种表示方法是一种轻松获得一个额外精度位的技巧。既然第一位总是等于1，那么我们就不需要显式地表示它。

（2）非规格化的

```
s |00000000|     frac     |
```

当阶码域为全0时，所表示的数是`非规格化`形式。在这种情况下，阶码值是E = 1 - Bias，而尾数的值是M = f，也就是小数字段的值，不包含隐含的开头的1。

非规格化数有两个用途，首先，它们提供了一种表示数字0的方法，因为使用规格化数，我们必须总是使M >= 1，因此我们就不能表示0。实际上，+0.0的浮点表示的位模式为全0：符号位是0，阶码字段全为0（表明是一个非规格化值），而小数域也全为0，这就得到M = f = 0。令人奇怪的是，当符号位为1，而其他域全为0时，我们得到值-0.0。根据IEEE的浮点格式，值+0.0和-0.0在某些方面被认为是不同的，而在其他方面是相同的。

非规格化数的另外一个功能是表示那些非常接近于0.0的数。它们提供了一种属性，称为`逐渐下溢`，其中，可能的数值分布均匀地接近于0.0。

（3）特殊值

（3a）无穷大

```
s |11111111|0000000000000000000000|
```

（3b）NaN

```
s |11111111|     ≠0     |
```

最后一类数值是指阶码全为1的时候出现的。当小数域全为0时，得到的值表示无穷，当s = 0时是+∞，或者当s = 1时是-∞，当我们把两个非常大的数相乘，或者除以零时，无穷能够表示溢出的结果。当小数域为非零时，结果值被称为“NaN”，即“不是一个数（Not a Number）”的缩写。一些运算的结果不能是实数或无穷，就会返回这样的NaN值，比如当计算(-1) ^ 0.5或∞ - ∞时。在某些应用中，表示未初始化的数据时，它们也很有用处。
### 2.4.3 数字示例
### 2.4.4 舍入

`向偶数舍入`（默认方式）：将数字向上或者向下舍入，使得结果的最低有效数字是偶数。

`向零舍入`：把正数向下舍入，把负数向上舍入。

`向下舍入`：把正数和负数都向下舍入。

`向上舍入`：把正数和负数都向上舍入。

向偶数舍入看上去好像是个相当随意的目标——有什么理由偏向取偶数呢？为什么不始终把位于两个可表示的值中间的值都向上舍入呢？使用这种方法的一个问题就是很容易假想到这样的场景：这种方法舍入一组数值，会在计算这些值的平均数中引入统计偏差。我们采用这种方式舍入得到的一组数的平均值将比这些数本身的平均值略高一些。相反，如果我们总是把两个可表示值中间的数字向下舍入，那么舍入后的一组数的平均值将比这些数本身的平均值略低一些。向偶数舍入在大多数现实情况中避免了这种统计偏差。在50%的时间里，它将向上舍入，而在50%的时间里，它将向下舍入。
### 2.4.5 浮点运算

浮点加法具有交换性，但不具有结合性。另一方面，浮点加法满足了单调性属性：如果a >= b，那么对于任何a、b以及x的值，除了NaN，都有x + a >= x + b。无符号或补码加法不具有这个实数（和整数）加法的属性。

浮点乘法是可交换的，但不具有结合性。另一方面，浮点乘法满足单调性。此外，只要a ≠ NaN，就有a \* a >= 0。
### 2.4.6 C语言中的浮点数

（1）从int转换成float，数字不会溢出，但是可能被舍入。

（2）从int或float转换成double，因为double有更大的范围（也就是可表示值的范围），也有更高的精度（也就是有效位数），所以能够保留精确的数值。

（3）从double转换成float，因为范围要小一些，所以值可能溢出成+∞或-∞。另外，由于精度较小，它还可能被舍入。

（4）从float或者double转换成int，值将会向零舍入。
## 2.5 小结

# 第1章 计算机系统漫游

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```
## 1.1 信息就是位+上下文

hello程序的生命周期是从一个`源程序`（或者说`源文件`）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是hello.c。源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为`字节`。每个字节表示程序中的某些文本字符。

像hello.c这样只由ASCII字符构成的文件称为`文本文件`，所有其他文件都称为`二进制文件`。

系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。
## 1.2 程序被其他程序翻译成不同的格式

hello程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行hello.c程序，每条C语句都必须被其他程序转化为一系列的低级`机器语言`指令。然后这些指令按照一种称为`可执行目标程序`的格式打好包，并以`二进制磁盘文件`的形式存放起来。目标程序也称为`可执行目标文件`。

在Unix系统上，从源文件到目标文件的转化是由`编译器驱动程序`完成的：

```
linux> gcc -o hello hello.c
```

在这里，GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。这个翻译过程可分为四个阶段完成。执行这四个阶段的程序（`预处理器`、`编译器`、`汇编器`和`链接器`）一起构成了`编译系统`。

（1）`预处理阶段`。预处理器根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的#include \<stdio.h\>命令告诉预处理器读取头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序hello.i。

（2）`编译阶段`。编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含函数main的定义，如下所示：

```
1  main:
2   subq    $8, %rsp
3   movl    $.LCO, %edi
4   call    puts
5   movl    $0, %eax
6   addq    $8, %rsp
7   ret
```

定义中2\~7行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。

（3）`汇编阶段`。接下来，汇编器将hello.s翻译成机器语言指令，把这些指令打包成一种叫做`可重定位目标程序`的格式，并将结果保存在目标文件hello.o中。hello.o是一个二进制文件，它包含的17个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。

（4）`链接阶段`。hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器就负责处理这种合并。结果就得到hello文件，它是一个`可执行目标文件`（或者简称为`可执行文件`），可以被加载到内存中，由系统执行。
## 1.3 了解编译系统如何工作是大有益处的

（1）`优化程序性能`。现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在C程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C语句转化为机器代码的方式。比如，`一个switch语句是否总是比一系列的if-else语句高效得多`？`一个函数调用的开销有多大`？`while循环比for循环更有效吗`？`指针引用比数组索引更有效吗`？`为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢`？`为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快`？

（2）`理解链接时出现的错误`。一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，`链接器报告说它无法解析一个引用，这是什么意思`？`静态变量和全局变量的区别是什么`？`如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么`？`静态库和动态库的区别是什么`？`我们在命令行上排列库的顺序有什么影响`？最严重的是，`为什么有些链接错误直到运行时才会出现`？

（3）`避免安全漏洞`。多年来，缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。
## 1.4 处理器读并解释储存在内存中的指令

shell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。
### 1.4.1 系统的硬件组成

（1）总线

`总线`是贯穿整个系统的一组电子管道，它携带信息字节并负责在各个部件间传递。通过总线被设计成传送定长的字节块，也就是`字`。字中的字节数（即`字长`）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32位），要么是8个字节（64位）。

（2）I/O设备

每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。`控制器`是I/O设备本身或者系统的主印制电路板（通常称作`主板`）上的`芯片组`。而`适配器`则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。

（3）主存

`主存`时一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组`动态随机存取存储器`（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。比如，在运行Linux的x86-64机器上，short类型的数据需要2个字节，int和float类型需要4个字节，而long和double类型需要8个字节。

（4）处理器

中央处理单元（CPU），简称`处理器`，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为`程序计数器`（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由`指令集架构`决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。

这样的简单操作并不多，它们围绕着`主存`、`寄存器文件`和`算术/逻辑单元`（ALU）进行。`寄存器文件`是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作。

1）`加载`：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。

2）`存储`：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。

3）`操作`：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。

4）`跳转`：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值。

处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：`指令集架构`描述的是每条机器代码指令的效果；而`微体系结构`描述的是处理器实际上是如何实现的。
### 1.4.2 运行hello程序

初始时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串”./hello"后，shell程序将字符逐一读入寄存器，再把它存放到内存中。

当我们在键盘上敲回车时，shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello, world\\n”。

利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。

一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将“hello, world\\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。
## 1.5 高速缓存至关重要

位于处理器芯片上的`L1高速缓存`的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的`L2高速缓存`通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5\~10倍。L1和L2的高速缓存时用一种叫做`静态随机访问存储器`（SRAM）的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：L1、L2和L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的`局部性原理`，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。
## 1.6 存储设备形成层次结构

存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，`寄存器文件就是L1的高速缓存`，`L1是L2的高速缓存`，`L2是L3的高速缓存`，`L3是主存的高速缓存`，而`主存又是磁盘的高速缓存`。`在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存`。
## 1.7 操作系统管理硬件

操作系统有两个基本功能：（1）防止硬件被失控的应用程序滥用。（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（`进程`、`虚拟内存`和`文件`）来实现这两个功能。`文件是对I/O设备的抽象表示`，`虚拟内存是对主存和磁盘I/O设备的抽象表示`，`进程则是对处理器、主存和I/O设备的抽象表示`。
### 1.7.1 进程

`进程`是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为`上下文切换`。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行`上下文切换`，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

最开始，只有shell进程在运行，即等待命令行上的输入。当我们让它运行hello程序时，shell通过调用一个专门的函数，即系统调用
